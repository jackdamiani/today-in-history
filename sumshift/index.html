<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SumShift!r</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        .main-container {
            display: flex;
            gap: 40px;
        }
        .container {
            max-width: 600px;
        }
        .play-container {
            flex: 1;
        }
        .controls {
            margin-bottom: 20px;
        }
        label {
            margin-right: 10px;
        }
        input {
            padding: 5px;
            font-size: 16px;
        }
        button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
        }
        .options {
            margin-bottom: 20px;
        }
        .option-btn {
            padding: 8px 16px;
            margin-right: 10px;
            font-size: 14px;
            border: 2px solid #999;
            background-color: white;
            cursor: pointer;
        }
        .option-btn.selected {
            border-color: #333;
            font-weight: bold;
        }
        #grid {
            display: grid;
            gap: 4px;
            margin-top: 20px;
            width: fit-content;
        }
        #playGrid {
            display: grid;
            gap: 4px;
            margin-top: 20px;
            width: fit-content;
        }
        .square {
            width: 40px;
            height: 40px;
            background-color: #f0f0f0;
            border: 1px solid #000;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .square:hover {
            background-color: #e0e0e0;
        }
        .square.jelly {
            background-color: rgba(173, 216, 230, 0.6);
            border: 1px solid #000;
        }
        .square.candy {
            background-color: rgba(255, 192, 203, 0.6);
            border: 1px solid #000;
        }
        .square.hole {
            background-color: rgba(255, 255, 255, 1);
            border: none;
        }
        .square.regular {
            background-color: rgba(255, 255, 255, 0.6);
            border: 1px solid #000;
        }
        .square.record {
            background-color: rgba(0, 0, 0, 0.6);
            border: 1px solid #000;
        }
        .play-square {
            width: 40px;
            height: 40px;
            border: 1px solid #000;
        }
        .play-square.jelly {
            background-color: rgba(173, 216, 230, 0.6);
            border: 1px solid #000;
        }
        .play-square.candy {
            background-color: rgba(255, 192, 203, 0.6);
            border: 1px solid #000;
        }
        .play-square.hole {
            background-color: rgba(255, 255, 255, 1);
            border: none;
        }
        .play-square.regular {
            background-color: rgba(255, 255, 255, 0.6);
            border: 1px solid #000;
        }
        .play-square.record {
            background-color: rgba(0, 0, 0, 0.6);
            border: 1px solid #000;
        }
        .play-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }
        </style>
    </head>
    <body>
        <div class="main-container">
        <div class="container">
            <h1>Sum Shift</h1>
            <h2>Design your level!</h2>
            <div class="controls">
            <label for="gridSize">Grid Size:</label>
            <input type="number" id="gridSize" min="5" max="10" value="5">
            <button onclick="adjustGridSize()">Adjust Grid Size</button>
            </div>
            <div class="options" id="options"></div>
            <div id="grid"></div>
            <div class="controls">
            <label for="maxNumber">How many different numbers? <button type="button" class="info-btn" title="Values between 3-7. Lower = easier, Higher = harder">?</button></label>
            <input type="number" id="maxNumber" min="3" max="7" value="3">
            </div>
            <button onclick="generateLevel()">Generate Level</button>
        </div>
        <div class="play-container">
            <h2>Play your level! <button type="button" class="info-btn"  title="Populate level to play. Click on two adjacent squares to swap. Try to get 3 in a row. Hit reset to reset the whole level">?</button></h2>
            
            <div id="playGrid"></div>
            <button type="button" style="margin-top: 20px;" onclick="populateLevel()">Populate and Play!</button>
        </div>
        </div>

        <script>
        const TILE_TYPES = {
            regular: 'rgba(255, 255, 255, 0.6)',
            hole: 'rgba(255, 255, 255, 1)',
            jelly: 'rgba(173, 216, 230, 0.6)',
            candy: 'rgba(255, 192, 203, 0.6)',
            record: 'rgba(0, 0, 0, 0.6)'
        };

        let selectedType = null;
        let gridSize = 5;
        let lastSwappedSquares = null;

        function initializeOptions() {
            const optionsContainer = document.getElementById('options');
            optionsContainer.innerHTML = '';
            
            Object.keys(TILE_TYPES).forEach(type => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                btn.onclick = () => selectOption(type, btn);
                optionsContainer.appendChild(btn);
            });
        }

        function selectOption(type, btn) {
            document.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            selectedType = type;
        }

        function adjustGridSize() {
            const size = parseInt(document.getElementById('gridSize').value);
            if (size < 5 || size > 10) {
                alert('Please enter a number between 5 and 10');
                return;
            }

            gridSize = size;
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${size}, 40px)`;

            for (let i = 0; i < size * size; i++) {
                const square = document.createElement('div');
                square.className = 'square regular';
                square.onclick = () => updateSquare(square);
                grid.appendChild(square);
            }
        }

        function updateSquare(square) {
            if (!selectedType) {
                alert('Please select a tile type first');
                return;
            }
            square.id = selectedType;
            square.className = `square ${selectedType}`;
        }

        function generateLevel() {
            const squares = document.querySelectorAll('#grid .square');
            const playGrid = document.getElementById('playGrid');
            playGrid.innerHTML = '';
            playGrid.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;

            squares.forEach(square => {
                const playSquare = document.createElement('div');
                playSquare.className = `play-square ${square.className.replace('square ', '')}`;
                playGrid.appendChild(playSquare);
            });
        }

        let selectedSquare = null;

        function isAdjacent(square1, square2) {
            const allSquares = Array.from(document.querySelectorAll('#playGrid .play-square'));
            const index1 = allSquares.indexOf(square1);
            const index2 = allSquares.indexOf(square2);
            const row1 = Math.floor(index1 / gridSize);
            const col1 = index1 % gridSize;
            const row2 = Math.floor(index2 / gridSize);
            const col2 = index2 % gridSize;
            return Math.abs(row1 - row2) + Math.abs(col1 - col2) === 1;
        }

        function addSpecialToSquare(square, special) {
            const validSpecials = ['2', '4', '5', 'L'];
            if (!validSpecials.includes(special)) {
                console.error('Invalid special. Use: 2, 4, 5, or L');
                return;
            }
            
            square.style.position = 'relative';
            let specialElement = square.querySelector('.special-badge');
            
            if (!specialElement) {
                specialElement = document.createElement('div');
                specialElement.className = 'special-badge';
                specialElement.style.position = 'absolute';
                specialElement.style.top = '2px';
                specialElement.style.right = '2px';
                specialElement.style.fontSize = '8px';
                specialElement.style.fontWeight = 'bold';
                specialElement.style.backgroundColor = '#000';
                specialElement.style.color = '#fff';
                specialElement.style.width = '12px';
                specialElement.style.height = '12px';
                specialElement.style.borderRadius = '50%';
                specialElement.style.display = 'flex';
                specialElement.style.alignItems = 'center';
                specialElement.style.justifyContent = 'center';
                square.appendChild(specialElement);
            }
            
            specialElement.textContent = special;
        }

        function removeSpecialFromSquare(square) {
            const specialElement = square.querySelector('.special-badge');
            if (specialElement) {
            square.removeChild(specialElement);
            }
        }

        function checkSpecialInSquare(square) {
            const specialElement = square.querySelector('.special-badge');
            return specialElement ? specialElement.textContent : null;
        }

        function populateWithSpecials() {
            // For testing purposes only. Populates all playable squares with random specials.
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            const specials = ['2', 'L', '4', '5'];
            
            playSquares.forEach((square, index) => {
                const isPlayable = square.className.includes('jelly') || square.className.includes('regular');
                if (isPlayable) {
                    const randomSpecial = specials[Math.floor(Math.random() * specials.length)];
                    addSpecialToSquare(square, randomSpecial);
                }
            });
        }

        

        function swapSquares(square1, square2, index1, index2) {
            // Animate scaling up
            square1.style.transition = 'transform 0.2s ease-in-out';
            square2.style.transition = 'transform 0.2s ease-in-out';
            square1.style.transform = 'scale(1.3)';
            square2.style.transform = 'scale(1.3)';

            setTimeout(() => {
                // Swap the main text symbols
                const tempText = square1.textContent;
                square1.textContent = square2.textContent;
                square2.textContent = tempText;

                // Swap special badges using addSpecialToSquare
                const badge1 = square1.querySelector('.special-badge')?.textContent;
                const badge2 = square2.querySelector('.special-badge')?.textContent;

                // Clear current badges
                if (square1.querySelector('.special-badge')) square1.removeChild(square1.querySelector('.special-badge'));
                if (square2.querySelector('.special-badge')) square2.removeChild(square2.querySelector('.special-badge'));

                // Re-add swapped badges
                if (badge1) addSpecialToSquare(square2, badge1);
                if (badge2) addSpecialToSquare(square1, badge2);

                // Animate scaling back down
                square1.style.transform = 'scale(1)';
                square2.style.transform = 'scale(1)';
            }, 150);

            // Clean up transitions
            setTimeout(() => {
                square1.style.transition = '';
                square2.style.transition = '';
            }, 350);

            // Track swapped squares by index
            lastSwappedSquares = {
                square1: index1,
                square2: index2
            };
        }

        // // GLOBAL STATE
        let matches = new Set();
        let matchType = new Map();
        let allMatches = [];
        // let lastSwappedSquares = { square1: null, square2: null };

        // MAIN MATCH CHECK FUNCTION
        function checkForMatches() {
            matches.clear();
            matchType.clear();
            allMatches = [];

            const playSquares = Array.from(document.querySelectorAll('#playGrid .play-square'));

            // ------------------------
            // Check for 2x2 squares
            // ------------------------
            for (let row = 0; row < gridSize - 1; row++) {
                for (let col = 0; col < gridSize - 1; col++) {
                    const idx1 = row * gridSize + col;
                    const idx2 = idx1 + 1;
                    const idx3 = (row + 1) * gridSize + col;
                    const idx4 = idx3 + 1;

                    const sq1 = playSquares[idx1];
                    if (!sq1.textContent) continue;

                    if (sq1.textContent === playSquares[idx2].textContent &&
                        sq1.textContent === playSquares[idx3].textContent &&
                        sq1.textContent === playSquares[idx4].textContent) {

                        const matchGroup = [idx1, idx2, idx3, idx4];
                        matchGroup.forEach(i => {
                            matches.add(i);
                            matchType.set(i, 'gray');
                        });
                        allMatches.push(matchGroup);
                    }
                }
            }

            // ------------------------
            // Check for L & T shapes (5 squares)
            // ------------------------
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = playSquares[idx];
                    if (!sq.textContent) continue;

                    const val = sq.textContent;

                    // Example: T pointing up
                    if (row > 1 && row < gridSize - 2 && col > 0 && col < gridSize - 1) {
                        const up2 = (row - 2) * gridSize + col;
                        const up = (row - 1) * gridSize + col;
                        const left = row * gridSize + col - 1;
                        const right = row * gridSize + col + 1;

                        if (playSquares[up2].textContent === val &&
                            playSquares[up].textContent === val &&
                            playSquares[left].textContent === val &&
                            playSquares[right].textContent === val) {

                            const matchGroup = [idx, up2, up, left, right];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, 'lightgreen');
                            });
                            allMatches.push(matchGroup);

                            // Place special only if caused by last swap
                            const triggeringIndex = matchGroup.find(i =>
                                i === lastSwappedSquares.square1 ||
                                i === lastSwappedSquares.square2
                            );
                            if (triggeringIndex !== undefined) {
                                addSpecialToSquare(playSquares[triggeringIndex], 'L');
                            }

                            continue;
                        }
                    }

                    // Add more L/T orientations here following the same pattern
                    // T pointing down, left, right
                    // L shapes up-left, up-right, down-left, down-right
                }
            }

            // ------------------------
            // Horizontal matches (3+)
            // ------------------------
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = playSquares[idx];
                    if (!sq.textContent) continue;

                    // 5 in a row
                    if (col <= gridSize - 5) {
                        const idx2 = idx + 1;
                        const idx3 = idx + 2;
                        const idx4 = idx + 3;
                        const idx5 = idx + 4;

                        if (sq.textContent === playSquares[idx2].textContent &&
                            sq.textContent === playSquares[idx3].textContent &&
                            sq.textContent === playSquares[idx4].textContent &&
                            sq.textContent === playSquares[idx5].textContent) {

                            const matchGroup = [idx, idx2, idx3, idx4, idx5];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, 'green');
                            });
                            allMatches.push(matchGroup);
                            col += 4;
                            continue;
                        }
                    }

                    // 4 in a row
                    if (col <= gridSize - 4) {
                        const idx2 = idx + 1;
                        const idx3 = idx + 2;
                        const idx4 = idx + 3;

                        if (sq.textContent === playSquares[idx2].textContent &&
                            sq.textContent === playSquares[idx3].textContent &&
                            sq.textContent === playSquares[idx4].textContent) {

                            const matchGroup = [idx, idx2, idx3, idx4];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, 'red');
                            });
                            allMatches.push(matchGroup);
                            col += 3;
                            continue;
                        }
                    }

                    // 3 in a row
                    if (col <= gridSize - 3) {
                        const idx2 = idx + 1;
                        const idx3 = idx + 2;

                        if (sq.textContent === playSquares[idx2].textContent &&
                            sq.textContent === playSquares[idx3].textContent) {

                            const matchGroup = [idx, idx2, idx3];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, 'blue');
                            });
                            allMatches.push(matchGroup);
                            col += 2;
                        }
                    }
                }
            }

            // ------------------------
            // Vertical matches (3+)
            // ------------------------
            for (let col = 0; col < gridSize; col++) {
                for (let row = 0; row < gridSize; row++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = playSquares[idx];
                    if (!sq.textContent) continue;

                    // 5 vertical
                    if (row <= gridSize - 5) {
                        const idx2 = (row + 1) * gridSize + col;
                        const idx3 = (row + 2) * gridSize + col;
                        const idx4 = (row + 3) * gridSize + col;
                        const idx5 = (row + 4) * gridSize + col;

                        if (sq.textContent === playSquares[idx2].textContent &&
                            sq.textContent === playSquares[idx3].textContent &&
                            sq.textContent === playSquares[idx4].textContent &&
                            sq.textContent === playSquares[idx5].textContent) {

                            const matchGroup = [idx, idx2, idx3, idx4, idx5];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, 'orange');
                            });
                            allMatches.push(matchGroup);
                            row += 4;

                            // Place special only if caused by last swap
                            const triggeringIndex = matchGroup.find(i =>
                                i === lastSwappedSquares.square1 ||
                                i === lastSwappedSquares.square2
                            );
                            if (triggeringIndex !== undefined) {
                                addSpecialToSquare(playSquares[triggeringIndex], '5');
                            }

                            continue;
                        }
                    }

                    // 4 vertical
                    if (row <= gridSize - 4) {
                        const idx2 = (row + 1) * gridSize + col;
                        const idx3 = (row + 2) * gridSize + col;
                        const idx4 = (row + 3) * gridSize + col;

                        if (sq.textContent === playSquares[idx2].textContent &&
                            sq.textContent === playSquares[idx3].textContent &&
                            sq.textContent === playSquares[idx4].textContent) {

                            const matchGroup = [idx, idx2, idx3, idx4];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, 'red');
                            });
                            allMatches.push(matchGroup);
                            row += 3;
                            continue;
                        }
                    }

                    // 3 vertical
                    if (row <= gridSize - 3) {
                        const idx2 = (row + 1) * gridSize + col;
                        const idx3 = (row + 2) * gridSize + col;

                        if (sq.textContent === playSquares[idx2].textContent &&
                            sq.textContent === playSquares[idx3].textContent) {

                            const matchGroup = [idx, idx2, idx3];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, 'blue');
                            });
                            allMatches.push(matchGroup);
                            row += 2;
                        }
                    }
                }
            }

            // ------------------------
            // Animate matches
            // ------------------------
            let delay = 0;
            allMatches.forEach(matchGroup => {
                setTimeout(() => {
                    matchGroup.forEach(idx => {
                        const element = playSquares[idx];
                        element.style.color = matchType.get(idx);
                        element.style.transform = 'scale(1.5)';
                        element.style.transition = 'transform 0.5s ease-out';
                        setTimeout(() => {
                            element.style.transform = 'scale(1)';
                        }, 500);
                    });
                }, delay);
                delay += 500;
            });

            if (matches.size > 0) {
                clearMatches();
                return true;
            }

            return false;
        }

        // ------------------------
        // Clear matched squares
        // ------------------------
        function clearMatches() {
            const playSquares = Array.from(document.querySelectorAll('#playGrid .play-square'));
            matches.forEach(idx => {
                const element = playSquares[idx];

                // If this square already has a special badge, skip clearing textContent
                const hasSpecial = element.querySelector('.special-badge');
                
                element.style.backgroundColor = matchType.get(idx);

                setTimeout(() => {
                    if (!hasSpecial) {
                        element.textContent = '';
                    }
                    element.style.color = 'black';
                    element.style.backgroundColor = '';
                }, 500);
            });
        }


    


        function playGame() {
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            
            // Check for matches at the beginning
            checkForMatches();
            
            playSquares.forEach(square => {
            square.addEventListener('click', function() {
            const isSwappable = square.className.includes('regular') || square.className.includes('jelly');
            
            if (!isSwappable) return;
            
            if (!selectedSquare) {
            selectedSquare = square;
            square.style.border = '3px solid blue';
            } else if (selectedSquare === square) {
            selectedSquare.style.border = '1px solid #000';
            selectedSquare = null;
            } 
            // This is where the magic happens. If a valid swap, everything else happens!
            else if (isAdjacent(selectedSquare, square)) {
                const index1 = Array.from(playSquares).indexOf(selectedSquare);
                const index2 = Array.from(playSquares).indexOf(square);

                swapSquares(selectedSquare, square, index1, index2);

            selectedSquare.style.border = '1px solid #000';
            selectedSquare = null;
            
            // Check for matches after valid swap
            setTimeout(() => {
                checkForMatches();
            }, 200);
            } else {
            selectedSquare.style.border = '1px solid #000';
            selectedSquare = square;
            square.style.border = '3px solid blue';
            }
            });
            });
        }

        function populateLevel() {
            const maxNumber = parseInt(document.getElementById('maxNumber').value);
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            
            const validSquares = Array.from(playSquares).filter(square => {
            const classes = square.className;
            return classes.includes('jelly') || classes.includes('regular');
            });
            
            const numbers = new Array(playSquares.length).fill(null);
            const validIndices = Array.from(playSquares).map((square, index) => {
                const classes = square.className;
                if (classes.includes('jelly') || classes.includes('regular')) {
                    return index;
                }
                return -1;
            }).filter(idx => idx !== -1);
            
            for (let i = 0; i < validIndices.length; i++) {
            const gridIndex = validIndices[i];
            let placed = false;
            let attempts = 0;
            
            while (!placed && attempts < 100) {
                const randomNum = Math.floor(Math.random() * maxNumber) + 1;
                numbers[gridIndex] = randomNum;
                
                if (!hasConflictAtIndex(numbers, gridIndex)) {
                placed = true;
                }
                attempts++;  
            }
            
            if (!placed) {
                numbers[gridIndex] = ((i % maxNumber) + 1);
            }
            }
            
            validSquares.forEach((square, index) => {
            const gridIndex = validIndices[index];
            square.textContent = numbers[gridIndex];
            });

            const btn = event.target;
            btn.textContent = 'Reset Level';
            btn.onclick = resetLevel;

            playGame();
        }

        /**
         * Checks if there is a conflict at a specific index in the numbers array.
         * 
         * @param {number[]} numbers - Array of numbers to check for conflicts. Each element represents a value at a corresponding grid position.
         * @param {number} currentIndex - The index within the numbers array to check for conflicts at that specific position.
         * @returns {boolean} Returns true if a conflict exists at the currentIndex, false otherwise.
         * 
         * @description
         * This function validates whether placing a number at currentIndex in the numbers array
         * would create a conflict with existing play squares in the grid. It builds a set of valid
         * indices from the DOM and uses it to determine if the current position has a conflict.
         */
        function hasConflictAtIndex(numbers, currentIndex) {
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            const validIndices = new Set();

            for (let i = 0; i < playSquares.length; i++) {
                validIndices.add(i);
            }
                        
            // Check horizontal 3-in-a-row
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize - 2; col++) {
                    const idx1 = row * gridSize + col;
                    const idx2 = row * gridSize + col + 1;
                    const idx3 = row * gridSize + col + 2;
                    
                    if ([idx1, idx2, idx3].includes(currentIndex) && 
                        validIndices.has(idx1) && validIndices.has(idx2) && validIndices.has(idx3) &&
                        numbers[idx1] && numbers[idx2] && numbers[idx3]) {
                        if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3]) {
                            return true;
                        }
                    }
                }
            }
            
            // Check vertical 3-in-a-row
            for (let col = 0; col < gridSize; col++) {
                for (let row = 0; row < gridSize - 2; row++) {
                    const idx1 = row * gridSize + col;
                    const idx2 = (row + 1) * gridSize + col;
                    const idx3 = (row + 2) * gridSize + col;
                    
                    if ([idx1, idx2, idx3].includes(currentIndex) && 
                        validIndices.has(idx1) && validIndices.has(idx2) && validIndices.has(idx3) &&
                        numbers[idx1] && numbers[idx2] && numbers[idx3]) {
                        if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3]) {
                            return true;
                        }
                    }
                }
            }
            
            // Check 2x2 squares
            for (let row = 0; row < gridSize - 1; row++) {
                for (let col = 0; col < gridSize - 1; col++) {
                    const idx1 = row * gridSize + col;
                    const idx2 = row * gridSize + col + 1;
                    const idx3 = (row + 1) * gridSize + col;
                    const idx4 = (row + 1) * gridSize + col + 1;
                    
                    if ([idx1, idx2, idx3, idx4].includes(currentIndex) && 
                        validIndices.has(idx1) && validIndices.has(idx2) && validIndices.has(idx3) && validIndices.has(idx4) &&
                        numbers[idx1] && numbers[idx2] && numbers[idx3] && numbers[idx4]) {
                        if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3] && numbers[idx1] === numbers[idx4]) {
                            return true;
                        }
                    }
                }
            }

            
            
            return false;
        }

        function hasInitialMatches(numbers) {
            // Check for 2x2 squares
            for (let row = 0; row < gridSize - 1; row++) {
            for (let col = 0; col < gridSize - 1; col++) {
                const idx1 = row * gridSize + col;
                const idx2 = row * gridSize + col + 1;
                const idx3 = (row + 1) * gridSize + col;
                const idx4 = (row + 1) * gridSize + col + 1;
                
                if (numbers[idx1] === numbers[idx2] && 
                numbers[idx1] === numbers[idx3] && 
                numbers[idx1] === numbers[idx4]) {
                return true;
                }
            }
            }
            
            // Check horizontal 3-in-a-row
            for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize - 2; col++) {
                const idx1 = row * gridSize + col;
                const idx2 = row * gridSize + col + 1;
                const idx3 = row * gridSize + col + 2;
                
                if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3]) {
                return true;
                }
            }
            }
            
            // Check vertical 3-in-a-row
            for (let col = 0; col < gridSize; col++) {
            for (let row = 0; row < gridSize - 2; row++) {
                const idx1 = row * gridSize + col;
                const idx2 = (row + 1) * gridSize + col;
                const idx3 = (row + 2) * gridSize + col;
                
                if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3]) {
                return true;
                }
            }
            }
            
            return false;
        }

        function resetLevel() {
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            playSquares.forEach(square => {
            square.textContent = '';
            square.style.color = 'black';
            });

            const btn = event.target;
            btn.textContent = 'Populate and play!';
            btn.onclick = populateLevel;
        }

        initializeOptions();
        adjustGridSize();
    </script>
</body>
</html>