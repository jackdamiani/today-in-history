<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SumShift!r</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        .main-container {
            display: flex;
            gap: 40px;
        }
        .container {
            max-width: 600px;
        }
        .play-container {
            flex: 1;
        }
        .controls {
            margin-bottom: 20px;
        }
        label {
            margin-right: 10px;
        }
        input {
            padding: 5px;
            font-size: 16px;
        }
        button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
        }
        .options {
            margin-bottom: 20px;
        }
        .option-btn {
            padding: 8px 16px;
            margin-right: 10px;
            font-size: 14px;
            border: 2px solid #999;
            background-color: white;
            cursor: pointer;
        }
        .option-btn.selected {
            border-color: #333;
            font-weight: bold;
        }
        #grid {
            display: grid;
            gap: 4px;
            margin-top: 20px;
            width: fit-content;
        }
        #playGrid {
            display: grid;
            gap: 4px;
            margin-top: 20px;
            width: fit-content;
        }
        .square {
            width: 40px;
            height: 40px;
            background-color: #f0f0f0;
            border: 1px solid #000;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .square:hover {
            background-color: #e0e0e0;
        }
        .square.blue {
            background-color: rgba(173, 216, 230, 0.6);
            border: 1px solid #000;
        }
        .square.pink {
            background-color: rgba(255, 192, 203, 0.6);
            border: 1px solid #000;
        }
        .square.hole {
            background-color: rgba(255, 255, 255, 1);
            border: none;
        }
        .square.empty {
            background-color: rgba(255, 255, 255, 0.6);
            border: 1px solid #000;
        }
        .square.black {
            background-color: rgba(0, 0, 0, 0.6);
            border: 1px solid #000;
        }
        .play-square {
            width: 40px;
            height: 40px;
            border: 1px solid #000;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-square.blue {
            background-color: rgba(173, 216, 230, 0.6);
            border: 1px solid #000;
        }
        .play-square.pink {
            background-color: rgba(255, 192, 203, 0.6);
            border: 1px solid #000;
        }
        .play-square.hole {
            background-color: rgba(255, 255, 255, 1);
            border: none;
        }
        .play-square.empty {
            background-color: rgba(255, 255, 255, 0.6);
            border: 1px solid #000;
        }
        .play-square.black {
            background-color: rgba(0, 0, 0, 0.6);
            border: 1px solid #000;
        }
        .play-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            position: relative;
        }
        /* .num-to-go {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        } */
        .num-to-go {
            position: absolute;
            color: white;
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
        }

        .value-selector {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-left: 12px;
        }

        .value-selector span {
            width: 20px;
            text-align: center;
            font-weight: bold;
        }

        </style>
    </head>
    <body>
        <div class="main-container">
        <div class="container">
            <h1>Sum Shift</h1>
            <h2>Design your level!</h2>
            <div class="controls">
            <label for="gridSize">Grid Size:</label>
            <input type="number" id="gridSize" min="5" max="10" value="7">
            <button onclick="adjustGridSize()">Adjust Grid Size</button>
            </div>
            <div class="options" id="options"></div>
            <div id="grid"></div>
            <div class="controls">
            <label for="maxNumber">How many different numbers? <button type="button" class="info-btn" title="Values between 3-7. Lower = easier, Higher = harder">?</button></label>
            <input type="number" id="maxNumber" min="3" max="7" value="5">
            </div>
            <div class="controls">
            <label for="difficulty">Difficulty Level: <button type="button" class="info-btn" title="Controls how many matches happen when new tiles are added after a match. 0=random, 1=some, 2=none">?</button></label>
            <input type="number" id="difficulty" min="0" max="2" value="2">
            </div>
            <button onclick="generateLevel()">Generate Level</button>
        </div>
        <div class="play-container">
            <h2>Play your level! <button type="button" class="info-btn"  title="Populate level to play. Click on two adjacent squares to swap. Try to get 3 in a row. Hit reset to reset the whole level">?</button></h2>
            
            <div id="playGrid"></div>
            <button type="button" style="margin-top: 20px;" onclick="populateLevel()">Populate and Play!</button>
        </div>
        </div>

        <script>
        // // GLOBAL STATE
        let matches = new Set();
        let matchType = new Map();
        let allMatches = [];

        const NUMBER_COLORS = {
            '1': '#d32f2f', // red
            '2': '#1976d2', // blue
            '3': '#388e3c', // green
            '4': '#f57c00', // orange
            '5': '#212121', // dark gray
            '6': '#7b1fa2', // purple
            '7': '#616161'  // light gray
        };

        const DEPTH_COLORS = {
            blue: [
                'rgba(173, 216, 230, 0.3)',
                'rgba(173, 216, 230, 0.45)',
                'rgba(173, 216, 230, 0.6)',
                'rgba(173, 216, 230, 0.75)',
                'rgba(173, 216, 230, 0.9)'
            ],
            pink: [
                'rgba(255, 192, 203, 0.3)',
                'rgba(255, 192, 203, 0.45)',
                'rgba(255, 192, 203, 0.6)',
                'rgba(255, 192, 203, 0.75)',
                'rgba(255, 192, 203, 0.9)'
            ],
            black: [
                'rgba(0, 0, 0, 0.25)',
                'rgba(0, 0, 0, 0.4)',
                'rgba(0, 0, 0, 0.55)',
                'rgba(0, 0, 0, 0.7)',
                'rgba(0, 0, 0, 0.85)'
            ]
        };

        const TILE_TYPES = {
            empty: 'rgba(255, 255, 255, 0.6)',
            hole: 'rgba(255, 255, 255, 1)',
            blue: 'rgba(173, 216, 230, 0.6)',
            pink: 'rgba(255, 192, 203, 0.6)',
            black: 'rgba(0, 0, 0, 0.6)'
        };

        let gridSize = 5;
        let lastSwappedSquares = null;

        const TIMING = {
            SWAP_ANIMATION: 50,
            MATCH_ANIMATION: 1000,
            MATCH_CLEAR: 100,
            GRAVITY_STEP: 500,
        };

        let selectedType = null;
        let selectedValue = 1; // 1–8

        // // ALL FUNCTIONS

        function initializeOptions() {
            const optionsContainer = document.getElementById('options');
            optionsContainer.innerHTML = '';

            // Tile buttons
            Object.keys(TILE_TYPES).forEach(type => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                btn.onclick = () => selectOption(type, btn);
                optionsContainer.appendChild(btn);
            });

            // Counter UI
            const counter = document.createElement('div');
            counter.className = 'value-selector';

            const minus = document.createElement('button');
            minus.textContent = '-';
            minus.onclick = () => {
                if (selectedValue > 1) updateValue(selectedValue - 1);
            };

            const valueDisplay = document.createElement('span');
            valueDisplay.id = 'valueDisplay';
            valueDisplay.textContent = selectedValue;

            const plus = document.createElement('button');
            plus.textContent = '+';
            plus.onclick = () => {
                if (selectedValue < 8) updateValue(selectedValue + 1);
            };

            counter.append(minus, valueDisplay, plus);
            optionsContainer.appendChild(counter);
        }


        function selectOption(type, btn) {
            document.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            selectedType = type;
        }

        function updateValue(val) {
            selectedValue = val;
            document.getElementById('valueDisplay').textContent = selectedValue;
        }


        function adjustGridSize() {
            const size = parseInt(document.getElementById('gridSize').value);
            if (size < 5 || size > 10) {
                alert('Please enter a number between 5 and 10');
                return;
            }

            gridSize = size;
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${size}, 40px)`;

            for (let i = 0; i < size * size; i++) {
                const square = document.createElement('div');
                square.className = 'square empty';
                square.onclick = () => updateSquare(square);
                grid.appendChild(square);
            }
        }

        function updateSquare(square) {
            if (!selectedType) return;

            square.classList.remove('blue', 'pink', 'black', 'empty', 'hole');
            square.classList.add(selectedType);

            if (['blue', 'pink', 'black'].includes(selectedType)) {
                square.dataset.numToGo = selectedValue;
                applyDepthColor(square);
            } else {
                delete square.dataset.numToGo;
                square.style.backgroundColor = '';
            }
        }


        function incrementDepth(square) {
            if (!square.dataset.numToGo) return;

            let value = parseInt(square.dataset.numToGo, 10);
            if (value >= 5) return;

            square.dataset.numToGo = value + 1;
            applyDepthColor(square);
        }



        function applyDepthColor(square) {
            const type = square.classList.contains('blue') ? 'blue'
                    : square.classList.contains('pink') ? 'pink'
                    : square.classList.contains('black') ? 'black'
                    : null;

            if (!type || !square.dataset.numToGo) return;

            const depth = Math.min(parseInt(square.dataset.numToGo, 10), 5) - 1;
            square.style.backgroundColor = DEPTH_COLORS[type][depth];
        }


        function renderNumToGo(square) {
            let label = square.querySelector('.num-to-go');

            if (!label) {
                label = document.createElement('div');
                label.className = 'num-to-go';
                square.appendChild(label);
            }

            label.textContent = square.dataset.numToGo;
        }

        function generateLevel() {
            const squares = document.querySelectorAll('#grid .square');
            const playGrid = document.getElementById('playGrid');

            playGrid.innerHTML = '';
            playGrid.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;

            squares.forEach(square => {
                const playSquare = document.createElement('div');

                // Copy classes
                playSquare.className = `play-square ${square.className.replace('square ', '')}`;

                // ✅ ALWAYS initialize
                playSquare.dataset.numToGo = 0;

                // ✅ Override if editor square has depth
                if (square.dataset.numToGo) {
                    playSquare.dataset.numToGo = square.dataset.numToGo;
                    applyDepthColor(playSquare);
                }

                playGrid.appendChild(playSquare);
            });
        }



        // function generateLevel() {
        //     const squares = document.querySelectorAll('#grid .square');
        //     const playGrid = document.getElementById('playGrid');
        //     playGrid.innerHTML = '';
        //     playGrid.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;

        //     squares.forEach(square => {
        //         const playSquare = document.createElement('div');
        //         playSquare.className = `play-square ${square.className.replace('square ', '')}`;
        //         playGrid.appendChild(playSquare);
        //     });
        // }

        function numberColorMap() {
            const playSquares = document.querySelectorAll('#playGrid .play-square');

            playSquares.forEach(square => {
                const value = getSquareValue(square);

                if (!value) return; // empty square

                if (NUMBER_COLORS[value]) {
                    square.style.color = NUMBER_COLORS[value];
                }
            });
        }


        let selectedSquare = null;

        function isAdjacent(square1, square2) {
            const allSquares = Array.from(document.querySelectorAll('#playGrid .play-square'));
            const index1 = allSquares.indexOf(square1);
            const index2 = allSquares.indexOf(square2);
            const row1 = Math.floor(index1 / gridSize);
            const col1 = index1 % gridSize;
            const row2 = Math.floor(index2 / gridSize);
            const col2 = index2 % gridSize;
            return Math.abs(row1 - row2) + Math.abs(col1 - col2) === 1;
        }

        function addSpecialToSquare(square, special) {
            const validSpecials = ['2', '4', '5', 'L', 'T'];
            if (!validSpecials.includes(special)) {
                console.error('Invalid special. Use: 2, 4, 5, L, or T');
                return;
            }
            
            square.style.position = 'relative';
            let specialElement = square.querySelector('.special-badge');
            
            if (!specialElement) {
                specialElement = document.createElement('div');
                specialElement.className = 'special-badge';
                specialElement.style.position = 'absolute';
                specialElement.style.top = '2px';
                specialElement.style.right = '2px';
                specialElement.style.fontSize = '8px';
                specialElement.style.fontWeight = 'bold';
                specialElement.style.backgroundColor = '#000';
                specialElement.style.color = '#fff';
                specialElement.style.width = '12px';
                specialElement.style.height = '12px';
                specialElement.style.borderRadius = '50%';
                specialElement.style.display = 'flex';
                specialElement.style.alignItems = 'center';
                specialElement.style.justifyContent = 'center';
                square.appendChild(specialElement);
            }
            
            specialElement.textContent = special;
        }

        function removeSpecialFromSquare(square) {
            const specialElement = square.querySelector('.special-badge');
            if (specialElement) {
            square.removeChild(specialElement);
            }
        }

        function checkSpecialInSquare(square) {
            const specialElement = square.querySelector('.special-badge');
            return specialElement ? specialElement.textContent : null;
        }

        function populateWithSpecials() {
            // For testing purposes only. Populates all playable squares with random specials.
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            const specials = ['2', 'L', '4', '5'];
            
            playSquares.forEach((square, index) => {
                const isPlayable = square.className.includes('blue') || square.className.includes('empty');
                if (isPlayable) {
                    const randomSpecial = specials[Math.floor(Math.random() * specials.length)];
                    addSpecialToSquare(square, randomSpecial);
                }
            });
        }

        function createsMatchAt(index, i1, i2, v1, v2) {
            const row = Math.floor(index / gridSize);
            const col = index % gridSize;

            const val = getVirtualValueAt(index, i1, i2, v1, v2);
            if (!val) return false;

            const v = (r, c) =>
                getVirtualValueAt(r * gridSize + c, i1, i2, v1, v2);

            // =========================
            // HORIZONTAL 3
            // =========================
            if (
                col >= 2 &&
                v(row, col - 1) === val &&
                v(row, col - 2) === val
            ) {
                return true;
            }

            if (
                col >= 1 && col < gridSize - 1 &&
                v(row, col - 1) === val &&
                v(row, col + 1) === val
            ) {
                return true;
            }

            if (
                col < gridSize - 2 &&
                v(row, col + 1) === val &&
                v(row, col + 2) === val
            ) { 
                return true;
            }

            // =========================
            // VERTICAL 3
            // =========================
            if (
                row >= 2 &&
                v(row - 1, col) === val &&
                v(row - 2, col) === val
            ) { 
                return true; 
            }

            if (
                row >= 1 && row < gridSize - 1 &&
                v(row - 1, col) === val &&
                v(row + 1, col) === val
            ) { 
                return true; 
            }

            if (
                row < gridSize - 2 &&
                v(row + 1, col) === val &&
                v(row + 2, col) === val
            ) { 
                return true; 
            }

            // =========================
            // 2x2 SQUARES (4 orientations)
            // =========================
            const squares = [
                [[0, 0], [1, 0], [0, 1], [1, 1]],     // down-right
                [[0, 0], [-1, 0], [0, 1], [-1, 1]],   // up-right
                [[0, 0], [1, 0], [0, -1], [1, -1]],   // down-left
                [[0, 0], [-1, 0], [0, -1], [-1, -1]]  // up-left
            ];

            for (const pattern of squares) {
                if (
                    pattern.every(([dr, dc]) => {
                        const r = row + dr;
                        const c = col + dc;
                        return inBounds(r, c) && v(r, c) === val;
                    })
                ) {
                    return true;
                }
            }
            return false;
        }



        function isValidSwap(square1, square2, index1, index2) {

            // Only blue or empty can be swapped
            const allowed = sq =>
                sq.classList.contains('empty') ||
                sq.classList.contains('blue');

            if (!allowed(square1) || !allowed(square2)) return false;

            const val1 = getSquareNumber(square1);
            const val2 = getSquareNumber(square2);
            if (!val1 || !val2) return false;

            // Check BOTH swapped positions
            return (
                createsMatchAt(index1, index1, index2, val1, val2) ||
                createsMatchAt(index2, index1, index2, val1, val2)
            );
        }

        function getVirtualValueAt(index, i1, i2, v1, v2) {
            if (index === i1) return v2;
            if (index === i2) return v1;
            return getSquareNumber(playSquares[index]);
        }

        function inBounds(row, col) {
            return row >= 0 && row < gridSize && col >= 0 && col < gridSize;
        }

        function shakeSquares(square1, square2) {
            const squares = [square1, square2];
            const duration = 300; // total shake duration in ms
            const magnitude = 10; // pixels to move left/right
            const steps = 6; // number of shakes

            squares.forEach(square => {
                square.style.transition = `transform ${duration / steps}ms ease-in-out`;
            });

            let count = 0;
            const interval = setInterval(() => {
                const offset = (count % 2 === 0 ? magnitude : -magnitude);
                squares.forEach(square => {
                    square.style.transform = `translateX(${offset}px)`;
                });
                count++;
                if (count > steps) {
                    clearInterval(interval);
                    // reset position
                    squares.forEach(square => {
                        square.style.transform = '';
                        square.style.transition = '';
                    });
                }
            }, duration / steps);
        }

        

        function swapSquares(square1, square2, index1, index2) {
            if (!isValidSwap(square1, square2, index1, index2)) {
                shakeSquares(square1, square2);
                return;
            }


            // Animate scaling up
            square1.style.transition = 'transform 0.2s ease-in-out';
            square2.style.transition = 'transform 0.2s ease-in-out';
            square1.style.transform = 'scale(1.3)';
            square2.style.transform = 'scale(1.3)';

            setTimeout(() => {
            // Get ONLY the text node (not badge text)
            const getMainText = (square) => {
                return [...square.childNodes]
                    .find(n => n.nodeType === Node.TEXT_NODE);
            };

            const textNode1 = getMainText(square1);
            const textNode2 = getMainText(square2);

            const tempText = textNode1?.textContent || '';
            if (textNode1) textNode1.textContent = textNode2?.textContent || '';
            if (textNode2) textNode2.textContent = tempText;

            // Get badge values
            const badge1 = square1.querySelector('.special-badge')?.textContent;
            const badge2 = square2.querySelector('.special-badge')?.textContent;

            // Remove existing badges
            square1.querySelector('.special-badge')?.remove();
            square2.querySelector('.special-badge')?.remove();

            // Re-add swapped badges
            if (badge1) addSpecialToSquare(square2, badge1);
            if (badge2) addSpecialToSquare(square1, badge2);

            // Animate scaling back down
            square1.style.transform = 'scale(1)';
            square2.style.transform = 'scale(1)';
        }, TIMING.SWAP_ANIMATION);

            // Clean up transitions
            setTimeout(() => {
                square1.style.transition = '';
                square2.style.transition = '';
            }, TIMING.SWAP_ANIMATION + 50);

            // Track swapped squares by index
            lastSwappedSquares = {
                square1: index1,
                square2: index2
            };
        }

        function applyNumberColor(square, value) {
            square.style.color = NUMBER_COLORS[value] || 'black';
        }

        function setSquareValue(square, value) {
            square.textContent = value;

            if (value !== '') {
                applyNumberColor(square, value);
            } else {
                square.style.color = '';
            }
        }

        function getSquareNumber(square) {
            if (!square.textContent) return ''; // empty squares
            return square.textContent.trim()[0]; // first character only
        }


        // MAIN MATCH CHECK FUNCTION
        function checkForMatches() {
            matches.clear();
            matchType.clear();
            allMatches = [];

            playSquares = Array.from(document.querySelectorAll('#playGrid .play-square'));

            // ------------------------
            // Horizontal matches 5
            // ------------------------
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = getSquareNumber(playSquares[idx]);
                    if (!sq) continue;

                    // 5 in a row
                    if (col <= gridSize - 5) {
                        const idx2 = idx + 1;
                        const idx3 = idx + 2;
                        const idx4 = idx + 3;
                        const idx5 = idx + 4;

                        if (sq === getSquareNumber(playSquares[idx2]) &&
                            sq === getSquareNumber(playSquares[idx3]) &&
                            sq === getSquareNumber(playSquares[idx4]) &&
                            sq === getSquareNumber(playSquares[idx5])) {

                            const matchGroup = [idx, idx2, idx3, idx4, idx5];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, NUMBER_COLORS['5']);
                            });
                            allMatches.push(matchGroup);
                            col += 4;

                            // Place special only if caused by last swap
                            const triggeringIndex = matchGroup.find(i =>
                                i === lastSwappedSquares.square1 ||
                                i === lastSwappedSquares.square2
                            );
                            if (triggeringIndex !== undefined) {
                                addSpecialToSquare(playSquares[triggeringIndex], '5');
                            }
                            continue;
                        }
                    }
                }
            }

            // ------------------------
            // Vertical matches 5
            // ------------------------
            for (let col = 0; col < gridSize; col++) {
                for (let row = 0; row < gridSize; row++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = getSquareNumber(playSquares[idx]);
                    if (!sq) continue;

                    // 5 vertical
                    if (row <= gridSize - 5) {
                        const idx2 = (row + 1) * gridSize + col;
                        const idx3 = (row + 2) * gridSize + col;
                        const idx4 = (row + 3) * gridSize + col;
                        const idx5 = (row + 4) * gridSize + col;

                        if (sq === getSquareNumber(playSquares[idx2]) &&
                            sq === getSquareNumber(playSquares[idx3]) &&
                            sq === getSquareNumber(playSquares[idx4]) &&
                            sq === getSquareNumber(playSquares[idx5])) {

                            const matchGroup = [idx, idx2, idx3, idx4, idx5];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, NUMBER_COLORS['5']);
                            });
                            allMatches.push(matchGroup);
                            row += 4;

                            // Place special only if caused by last swap
                            const triggeringIndex = matchGroup.find(i =>
                                i === lastSwappedSquares.square1 ||
                                i === lastSwappedSquares.square2
                            );
                            if (triggeringIndex !== undefined) {
                                addSpecialToSquare(playSquares[triggeringIndex], '5');
                            }

                            continue;
                        }
                    }
                }
            }

            // ------------------------
            // Check for L & T shapes (5 squares)
            // ------------------------
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = getSquareNumber(playSquares[idx]);
                    if (!sq) continue;

                    const val = sq;

                    const tryMatch = (matchGroup, special_letter) => {
                        matchGroup.forEach(i => {
                            matches.add(i);
                            matchType.set(i, NUMBER_COLORS['1']);
                        });
                        allMatches.push(matchGroup);

                        const triggeringIndex = matchGroup.find(i =>
                            i === lastSwappedSquares.square1 ||
                            i === lastSwappedSquares.square2
                        );
                        if (triggeringIndex !== undefined) {
                            addSpecialToSquare(playSquares[triggeringIndex], special_letter);
                        }
                    };

                    // ========================
                    // T SHAPES
                    // ========================

                    // T pointing UP
                    if (row > 1 && row < gridSize - 2 && col > 0 && col < gridSize - 1) {
                        const up2 = (row - 2) * gridSize + col;
                        const up = (row - 1) * gridSize + col;
                        const left = row * gridSize + col - 1;
                        const right = row * gridSize + col + 1;

                        if ([up2, up, left, right].every(i => getSquareNumber(playSquares[i]) === val)) {
                            tryMatch([idx, up2, up, left, right], 'T');
                            continue;
                        }
                    }

                    // T pointing DOWN
                    if (row < gridSize - 3 && col > 0 && col < gridSize - 1) {
                        const down = (row + 1) * gridSize + col;
                        const down2 = (row + 2) * gridSize + col;
                        const left = row * gridSize + col - 1;
                        const right = row * gridSize + col + 1;

                        if ([down, down2, left, right].every(i => getSquareNumber(playSquares[i]) === val)) {
                            tryMatch([idx, down, down2, left, right], 'T');
                            continue;
                        }
                    }

                    // T pointing LEFT
                    if (col > 1 && row > 0 && row < gridSize - 1) {
                        const left = row * gridSize + col - 1;
                        const left2 = row * gridSize + col - 2;
                        const up = (row - 1) * gridSize + col;
                        const down = (row + 1) * gridSize + col;

                        if ([left, left2, up, down].every(i => getSquareNumber(playSquares[i]) === val)) {
                            tryMatch([idx, left, left2, up, down], 'T');
                            continue;
                        }
                    }

                    // T pointing RIGHT
                    if (col < gridSize - 3 && row > 0 && row < gridSize - 1) {
                        const right = row * gridSize + col + 1;
                        const right2 = row * gridSize + col + 2;
                        const up = (row - 1) * gridSize + col;
                        const down = (row + 1) * gridSize + col;

                        if ([right, right2, up, down].every(i => getSquareNumber(playSquares[i]) === val)) {
                            tryMatch([idx, right, right2, up, down], 'T');
                            continue;
                        }
                    }

                    // ========================
                    // L SHAPES
                    // ========================

                    // L up-left
                    if (row > 1 && col > 1) {
                        const up = (row - 1) * gridSize + col;
                        const up2 = (row - 2) * gridSize + col;
                        const left = row * gridSize + col - 1;
                        const left2 = row * gridSize + col - 2;

                        if ([up, up2, left, left2].every(i => getSquareNumber(playSquares[i]) === val)) {
                            tryMatch([idx, up, up2, left, left2], 'L');
                            continue;
                        }
                    }

                    // L up-right
                    if (row > 1 && col < gridSize - 2) {
                        const up = (row - 1) * gridSize + col;
                        const up2 = (row - 2) * gridSize + col;
                        const right = row * gridSize + col + 1;
                        const right2 = row * gridSize + col + 2;

                        if ([up, up2, right, right2].every(i => getSquareNumber(playSquares[i]) === val)) {
                            tryMatch([idx, up, up2, right, right2], 'L');
                            continue;
                        }
                    }

                    // L down-left
                    if (row < gridSize - 2 && col > 1) {
                        const down = (row + 1) * gridSize + col;
                        const down2 = (row + 2) * gridSize + col;
                        const left = row * gridSize + col - 1;
                        const left2 = row * gridSize + col - 2;

                        if ([down, down2, left, left2].every(i => getSquareNumber(playSquares[i]) === val)) {
                            tryMatch([idx, down, down2, left, left2], 'L');
                            continue;
                        }
                    }

                    // L down-right
                    if (row < gridSize - 2 && col < gridSize - 2) {
                        const down = (row + 1) * gridSize + col;
                        const down2 = (row + 2) * gridSize + col;
                        const right = row * gridSize + col + 1;
                        const right2 = row * gridSize + col + 2;

                        if ([down, down2, right, right2].every(i => getSquareNumber(playSquares[i]) === val)) {
                            tryMatch([idx, down, down2, right, right2], 'L');
                            continue;
                        }
                    }
                }
            }

            // ------------------------
            // Horizontal matches 4
            // ------------------------
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = playSquares[idx];
                    if (!sq.textContent) continue;

                    // 4 in a row
                    if (col <= gridSize - 4) {
                        const idx2 = idx + 1;
                        const idx3 = idx + 2;
                        const idx4 = idx + 3;

                        if (sq === getSquareNumber(playSquares[idx2]) &&
                            sq === getSquareNumber(playSquares[idx3]) &&
                            sq === getSquareNumber(playSquares[idx4])) {

                            const matchGroup = [idx, idx2, idx3, idx4];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, NUMBER_COLORS['4']);
                            });
                            allMatches.push(matchGroup);
                            col += 3;

                            // Place special only if caused by last swap
                            const triggeringIndex = matchGroup.find(i =>
                                i === lastSwappedSquares.square1 ||
                                i === lastSwappedSquares.square2
                            );
                            if (triggeringIndex !== undefined) {
                                addSpecialToSquare(playSquares[triggeringIndex], '4');
                            }
                            continue;
                        }
                    }
                }
            }

            // ------------------------
            // Vertical matches 4
            // ------------------------
            for (let col = 0; col < gridSize; col++) {
                for (let row = 0; row < gridSize; row++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = getSquareNumber(playSquares[idx]);
                    if (!sq) continue;

                    // 4 vertical
                    if (row <= gridSize - 4) {
                        const idx2 = (row + 1) * gridSize + col;
                        const idx3 = (row + 2) * gridSize + col;
                        const idx4 = (row + 3) * gridSize + col;

                        if (sq === getSquareNumber(playSquares[idx2]) &&
                            sq === getSquareNumber(playSquares[idx3]) &&
                            sq === getSquareNumber(playSquares[idx4])) {

                            const matchGroup = [idx, idx2, idx3, idx4];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, NUMBER_COLORS['4']);
                            });
                            allMatches.push(matchGroup);
                            row += 3;

                            // Place special only if caused by last swap
                            const triggeringIndex = matchGroup.find(i =>
                                i === lastSwappedSquares.square1 ||
                                i === lastSwappedSquares.square2
                            );
                            if (triggeringIndex !== undefined) {
                                addSpecialToSquare(playSquares[triggeringIndex], '4');
                            }
                            continue;
                        }
                    }
                }
            }

            // ------------------------
            // Check for 2x2 squares
            // ------------------------
            for (let row = 0; row < gridSize - 1; row++) {
                for (let col = 0; col < gridSize - 1; col++) {
                    const idx1 = row * gridSize + col;
                    const idx2 = idx1 + 1;
                    const idx3 = (row + 1) * gridSize + col;
                    const idx4 = idx3 + 1;

                    const sq1 = getSquareNumber(playSquares[idx1]);
                    if (!sq1) continue;

                    if (sq1 === getSquareNumber(playSquares[idx2]) &&
                        sq1 === getSquareNumber(playSquares[idx3]) &&
                        sq1 === getSquareNumber(playSquares[idx4])) {

                        const matchGroup = [idx1, idx2, idx3, idx4];
                        matchGroup.forEach(i => {
                            matches.add(i);
                            matchType.set(i, NUMBER_COLORS['2']);
                        });
                        allMatches.push(matchGroup);

                        // Place special only if caused by last swap
                        const triggeringIndex = matchGroup.find(i =>
                            i === lastSwappedSquares.square1 ||
                            i === lastSwappedSquares.square2
                        );
                        if (triggeringIndex !== undefined) {
                            addSpecialToSquare(playSquares[triggeringIndex], '2');
                        }
                    }
                }
            }

            // ------------------------
            // Horizontal matches 3
            // ------------------------
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = getSquareNumber(playSquares[idx]);
                    if (!sq) continue;
                    // 3 in a row
                    if (col <= gridSize - 3) {
                        const idx2 = idx + 1;
                        const idx3 = idx + 2;

                        if (sq === getSquareNumber(playSquares[idx2]) &&
                            sq === getSquareNumber(playSquares[idx3])) {

                            const matchGroup = [idx, idx2, idx3];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, NUMBER_COLORS['3']);
                            });
                            allMatches.push(matchGroup);
                            col += 2;
                        }
                    }
                }
            }

            // ------------------------
            // Vertical matches 3
            // ------------------------
            for (let col = 0; col < gridSize; col++) {
                for (let row = 0; row < gridSize; row++) {
                    const idx = row * gridSize + col;
                    if (matches.has(idx)) continue;

                    const sq = getSquareNumber(playSquares[idx]);
                    if (!sq) continue;

                    // 3 vertical
                    if (row <= gridSize - 3) {
                        const idx2 = (row + 1) * gridSize + col;
                        const idx3 = (row + 2) * gridSize + col;

                        if (sq === getSquareNumber(playSquares[idx2]) &&
                            sq === getSquareNumber(playSquares[idx3])) {

                            const matchGroup = [idx, idx2, idx3];
                            matchGroup.forEach(i => {
                                matches.add(i);
                                matchType.set(i, NUMBER_COLORS['3']); 
                            });
                            allMatches.push(matchGroup);
                            row += 2;
                        }
                    }
                }
            }

            // ------------------------
            // Animate matches
            // ------------------------
            allMatches.forEach(matchGroup => {
                matchGroup.forEach(idx => {
                    const element = playSquares[idx];
                    element.style.color = matchType.get(idx);

                    // Start the "pop" effect
                    element.style.transform = 'scale(1)';
                    element.style.transition = `transform ${TIMING.MATCH_ANIMATION / 2}ms ease-out`;

                    // Force the browser to register the initial scale
                    element.getBoundingClientRect(); // this triggers reflow

                    // Grow element
                    element.style.transform = 'scale(1.5)';

                    // Shrink back after half the animation
                    setTimeout(() => {
                        element.style.transform = 'scale(1)';
                    }, TIMING.MATCH_ANIMATION / 2);
                });
            });


            if (matches.size > 0) {
                clearMatches();
                return true;
            }

            return false;
        }

        function clearMatches() {
            const playSquares = Array.from(document.querySelectorAll('#playGrid .play-square'));

            matches.forEach(idx => {
                const element = playSquares[idx];
                const hasSpecial = element.querySelector('.special-badge');
                element.style.backgroundColor = matchType.get(idx);

                setTimeout(() => {
                    if (!hasSpecial) {
                        element.textContent = '';
                    }

                    element.style.color = 'black';
                    element.style.backgroundColor = '';
                }, TIMING.MATCH_CLEAR);
            });

            setTimeout(() => {
                gravity();
            }, TIMING.GRAVITY_STEP + TIMING.MATCH_CLEAR);
        }


        function getSquareValue(square) {
            // Look only for the text node that represents the number
            for (let i = 0; i < square.childNodes.length; i++) {
                const node = square.childNodes[i];

                if (node.nodeType === Node.TEXT_NODE) {
                    const value = node.nodeValue.trim();
                    return value === '' ? '' : value;
                }
            }

            return '';
        }


        function setSquareValue(square, value) {
            // Remove ONLY text nodes (leave badges intact)
            for (let i = square.childNodes.length - 1; i >= 0; i--) {
                const node = square.childNodes[i];
                if (node.nodeType === Node.TEXT_NODE) {
                    node.remove();
                }
            }

            // Add new value if not empty
            if (value !== '') {
                square.prepend(document.createTextNode(value));
            }
        }


        function isFallTarget(square) {
            return square.classList.contains('empty') ||
                square.classList.contains('blue');
        }

        function isBlocker(square) {
            return square.classList.contains('hole') ||
                square.classList.contains('pink');
        }

        function isBlack(square) {
            return square.classList.contains('black')
        }


        function gravity() {
            const playSquares = Array.from(
                document.querySelectorAll('#playGrid .play-square')
            );

            let moved = false;

            for (let col = 0; col < gridSize; col++) {
                for (let row = gridSize - 1; row >= 0; row--) {
                    const idx = row * gridSize + col;
                    const current = playSquares[idx];

                    // =========================
                    // CASE 1: RECORD FALLS
                    // =========================
                    if (isBlack(current)) {
                        const belowRow = row + 1;
                        if (belowRow < gridSize) {
                            const below = playSquares[belowRow * gridSize + col];

                            // Black can fall onto non-hole squares
                            if (!isBlocker(below) && getSquareValue(below) === '' && !isBlack(below)) {

                                // ---- MOVE RECORD LAYER ----
                                below.classList.add('black');
                                below.dataset.numToGo = current.dataset.numToGo;

                                // ---- REMOVE RECORD FROM SOURCE ----
                                current.classList.remove('black');
                                current.classList.add('empty'); // becomes normal tile after falling
                                current.dataset.numToGo = 0;

                                // ---- VISUAL UPDATE ----
                                applyDepthColor(below);
                                current.style.backgroundColor = ''; // reverts to base tile color

                                moved = true;
                            }
                        }
                        continue;
                    }

                    // Skip if this square blocks gravity
                    if (isBlocker(current)) continue;

                    // =========================
                    // CASE 2: NORMAL NUMBER FALL
                    // =========================
                    if (!isFallTarget(current)) continue;
                    if (getSquareValue(current) !== '') continue;

                    // Look upward
                    for (let aboveRow = row - 1; aboveRow >= 0; aboveRow--) {
                        const aboveIdx = aboveRow * gridSize + col;
                        const above = playSquares[aboveIdx];

                        // Blockers stop the search
                        if (isBlocker(above)) break;

                        // Skip non-falling squares
                        if (!isFallTarget(above)) continue;

                        const aboveValue = getSquareValue(above);
                        if (aboveValue !== '') {

                            // ---- Move number ----
                            setSquareValue(current, aboveValue);
                            setSquareValue(above, '');

                            // ---- Move special badge ----
                            const badge = above.querySelector('.special-badge');
                            if (badge) {
                                badge.remove();
                                current.appendChild(badge);
                            }

                            moved = true;
                            break;
                        }
                    }
                }
            }

            if (moved) {
                // Things are still falling
                setTimeout(() => {
                    gravity();
                }, TIMING.GRAVITY_STEP);
            } else {
                // Gravity settled → fill → then check for matches
                setTimeout(() => {
                    gravityFill(difficulty);

                    setTimeout(() => {
                        // checkForMatches should:
                        // - clear matches
                        // - trigger gravity again if needed
                        checkForMatches();
                    }, TIMING.MATCH_ANIMATION);

                }, TIMING.GRAVITY_STEP);
            }

            numberColorMap();

        }


        function getNumbersArray() {
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            return Array.from(playSquares).map(square => {
                const val = getSquareValue(square);
                return val === '' ? null : val;
            });
        }


        function gravityFill(difficulty = 0) {
            const playSquares = Array.from(
                document.querySelectorAll('#playGrid .play-square')
            );

            const maxNumber = parseInt(
                document.getElementById('maxNumber').value
            );

            difficulty = parseInt(
                document.getElementById('difficulty').value
            );

            let numbers = getNumbersArray();

            for (let col = 0; col < gridSize; col++) {

                // Walk bottom → top
                for (let row = gridSize - 1; row >= 0; row--) {
                    const idx = row * gridSize + col;
                    const square = playSquares[idx];

                    // ❌ Never fill black cell itself
                    if (isBlack(square)) {
                        continue;
                    }

                    // Only fill valid empty fall targets
                    if (!isFallTarget(square)) {
                        continue;
                    }
                    if (getSquareValue(square) !== '') {
                        continue;
                    }
                        

                    let value;
                    let attempts = 0;

                    do {
                        value = String(Math.floor(Math.random() * maxNumber) + 1);
                        numbers[idx] = value;
                        attempts++;

                        if (difficulty === 0) break;
                        if (difficulty === 1 && Math.random() < 0.3) break;

                    } while (
                        difficulty === 2 &&
                        hasConflictAtIndex(numbers, idx) &&
                        attempts < 15
                    );

                    setSquareValue(square, value);
                    numbers[idx] = value;
                }
            }

            numberColorMap();
        }




        function playGame() {
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            
            // Check for matches at the beginning
            checkForMatches();
            
            playSquares.forEach(square => {
            square.addEventListener('click', function() {
            const isSwappable = square.className.includes('empty') || square.className.includes('blue');
            
            if (!isSwappable) return;
            
            if (!selectedSquare) {
            selectedSquare = square;
            square.style.border = '3px solid blue';
            } else if (selectedSquare === square) {
            selectedSquare.style.border = '1px solid #000';
            selectedSquare = null;
            } 
            // This is where the magic happens. If a valid swap, everything else happens!
            else if (isAdjacent(selectedSquare, square)) {
                const index1 = Array.from(playSquares).indexOf(selectedSquare);
                const index2 = Array.from(playSquares).indexOf(square);

                swapSquares(selectedSquare, square, index1, index2);

            selectedSquare.style.border = '1px solid #000';
            selectedSquare = null;
            
            // Check for matches after valid swap
            setTimeout(() => {
                checkForMatches();
            }, 200);
            } else {
            selectedSquare.style.border = '1px solid #000';
            selectedSquare = square;
            square.style.border = '3px solid blue';
            }
            });
            });
        }

        function populateLevel() {
            const maxNumber = parseInt(document.getElementById('maxNumber').value);
            const playSquares = document.querySelectorAll('#playGrid .play-square');
                      
            const numbers = new Array(playSquares.length).fill(null);
            const validIndices = Array.from(playSquares).map((square, index) => {
                const classes = square.className;
                if (classes.includes('blue') || classes.includes('empty')) {
                    return index;
                }
                return -1;
            }).filter(idx => idx !== -1);
            
            for (let i = 0; i < validIndices.length; i++) {
            const gridIndex = validIndices[i];
            let placed = false;
            let attempts = 0;
            
            while (!placed && attempts < 100) {
                const randomNum = Math.floor(Math.random() * maxNumber) + 1;
                numbers[gridIndex] = randomNum;
                
                if (!hasConflictAtIndex(numbers, gridIndex)) {
                placed = true;
                }
                attempts++;  
            }
            
            if (!placed) {
                numbers[gridIndex] = ((i % maxNumber) + 1);
            }
            }

            const validSquares = Array.from(playSquares).filter(square => {
                const classes = square.className;
                return classes.includes('blue') || classes.includes('empty');
            });

            validSquares.forEach((square, index) => {
                const gridIndex = validIndices[index];

                square.textContent = numbers[gridIndex];

                // Re-apply depth if this tile type supports it
                if (square.classList.contains('blue') ||
                    square.classList.contains('pink') ||
                    square.classList.contains('black')) {

                    if (!square.dataset.numToGo) {
                        square.dataset.numToGo = 1; // default depth
                    }

                    applyDepthColor(square);
                }
            });


            const btn = event.target;
            btn.textContent = 'Reset Level';
            btn.onclick = resetLevel;

            numberColorMap();

            playGame();
        }

        /**
         * Checks if there is a conflict at a specific index in the numbers array.
         * 
         * @param {number[]} numbers - Array of numbers to check for conflicts. Each element represents a value at a corresponding grid position.
         * @param {number} currentIndex - The index within the numbers array to check for conflicts at that specific position.
         * @returns {boolean} Returns true if a conflict exists at the currentIndex, false otherwise.
         * 
         * @description
         * This function validates whether placing a number at currentIndex in the numbers array
         * would create a conflict with existing play squares in the grid. It builds a set of valid
         * indices from the DOM and uses it to determine if the current position has a conflict.
         */
        function hasConflictAtIndex(numbers, currentIndex) {
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            const validIndices = new Set();

            for (let i = 0; i < playSquares.length; i++) {
                validIndices.add(i);
            }
                        
            // Check horizontal 3-in-a-row
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize - 2; col++) {
                    const idx1 = row * gridSize + col;
                    const idx2 = row * gridSize + col + 1;
                    const idx3 = row * gridSize + col + 2;
                    
                    if ([idx1, idx2, idx3].includes(currentIndex) && 
                        validIndices.has(idx1) && validIndices.has(idx2) && validIndices.has(idx3) &&
                        numbers[idx1] && numbers[idx2] && numbers[idx3]) {
                        if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3]) {
                            return true;
                        }
                    }
                }
            }
            
            // Check vertical 3-in-a-row
            for (let col = 0; col < gridSize; col++) {
                for (let row = 0; row < gridSize - 2; row++) {
                    const idx1 = row * gridSize + col;
                    const idx2 = (row + 1) * gridSize + col;
                    const idx3 = (row + 2) * gridSize + col;
                    
                    if ([idx1, idx2, idx3].includes(currentIndex) && 
                        validIndices.has(idx1) && validIndices.has(idx2) && validIndices.has(idx3) &&
                        numbers[idx1] && numbers[idx2] && numbers[idx3]) {
                        if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3]) {
                            return true;
                        }
                    }
                }
            }
            
            // Check 2x2 squares
            for (let row = 0; row < gridSize - 1; row++) {
                for (let col = 0; col < gridSize - 1; col++) {
                    const idx1 = row * gridSize + col;
                    const idx2 = row * gridSize + col + 1;
                    const idx3 = (row + 1) * gridSize + col;
                    const idx4 = (row + 1) * gridSize + col + 1;
                    
                    if ([idx1, idx2, idx3, idx4].includes(currentIndex) && 
                        validIndices.has(idx1) && validIndices.has(idx2) && validIndices.has(idx3) && validIndices.has(idx4) &&
                        numbers[idx1] && numbers[idx2] && numbers[idx3] && numbers[idx4]) {
                        if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3] && numbers[idx1] === numbers[idx4]) {
                            return true;
                        }
                    }
                }
            }

            
            
            return false;
        }

        function hasInitialMatches(numbers) {
            // Check for 2x2 squares
            for (let row = 0; row < gridSize - 1; row++) {
            for (let col = 0; col < gridSize - 1; col++) {
                const idx1 = row * gridSize + col;
                const idx2 = row * gridSize + col + 1;
                const idx3 = (row + 1) * gridSize + col;
                const idx4 = (row + 1) * gridSize + col + 1;
                
                if (numbers[idx1] === numbers[idx2] && 
                numbers[idx1] === numbers[idx3] && 
                numbers[idx1] === numbers[idx4]) {
                return true;
                }
            }
            }
            
            // Check horizontal 3-in-a-row
            for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize - 2; col++) {
                const idx1 = row * gridSize + col;
                const idx2 = row * gridSize + col + 1;
                const idx3 = row * gridSize + col + 2;
                
                if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3]) {
                return true;
                }
            }
            }
            
            // Check vertical 3-in-a-row
            for (let col = 0; col < gridSize; col++) {
            for (let row = 0; row < gridSize - 2; row++) {
                const idx1 = row * gridSize + col;
                const idx2 = (row + 1) * gridSize + col;
                const idx3 = (row + 2) * gridSize + col;
                
                if (numbers[idx1] === numbers[idx2] && numbers[idx1] === numbers[idx3]) {
                return true;
                }
            }
            }
            
            return false;
        }

        function resetLevel() {
            const playSquares = document.querySelectorAll('#playGrid .play-square');
            playSquares.forEach(square => {
            square.textContent = '';
            square.style.color = 'black';
            });

            const btn = event.target;
            btn.textContent = 'Populate and play!';
            btn.onclick = populateLevel;
        }

        initializeOptions();
        adjustGridSize();
    </script>
</body>
</html>